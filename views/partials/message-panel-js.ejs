<script>
  window.onload = () => {
    const messageList = new MessageList("messages");
    messageList.setCaller({
      name: "Caller"
    });
    messageList.setOperator({
      name: "Operator"
    });

    let endpoint = '/token/' + '<%- user.clientName %>';

    $(function () {
      $.ajax(endpoint)
        .done(function (token) {

          Twilio.Device.setup(token);
        })
        .fail(function () {
          alert('Could not authenticate!');
        });
    });


    let conn;
    Twilio.Device.connect(function (connection) {
      conn = connection;
    });

    /* Call a customer from a support ticket */
    function callCustomer(phoneNumber) {
      var params = {
        "phoneNumber": phoneNumber
      };
      Twilio.Device.connect(params);
    }

    Twilio.Device.ready(function (device) {
    });

    Twilio.Device.error(function (error) {
      console.log('Error: ' + error.message);
    });

    Twilio.Device.incoming(function (conn) {
      alert('Incoming connection from ' + conn.parameters.From);
      // accept the incoming connection and start two-way audio
      conn.accept();

      transcribe(conn);
    });

    function takeNextCall() {
      $.ajax('/connect/' + '<%- user.clientName %>')
        .done(function (text) {
          console.log(text);
          if(text === 'Empty Queue') {
            alert('Queue is currently empty');
          }
        })
        .fail(function () {
          alert('Could not connect!');
        });
    }

    function transcribe(conn) {
      const phoneNumber = conn.parameters.From;
      fetch('/watson/credentials')
        .then(function (response) {
          return response.text();
        }).then(function (token) {
          var stream = WatsonSpeech.SpeechToText.recognizeMicrophone({
            token: JSON.parse(token).token,
            object_mode: true,
            interim_results: true,
            mediaStream: conn.mediaStream.video.captureStream(),
            model: 'en-GB_NarrowbandModel'
          });

          stream.setEncoding('utf8'); // get text instead of Buffers for on data events

          stream.on('data', function (data) {
            messageList.addMessage('Caller', data);
          });

          stream.on('message', function (data) {
          });

          stream.on('error', function (err) {
          });

          var stream2 = WatsonSpeech.SpeechToText.recognizeMicrophone({
            token: JSON.parse(token).token,
            object_mode: true,
            interim_results: true,
          });

          stream2.setEncoding('utf8'); // get text instead of Buffers for on data events

          stream2.on('data', function (data) {
            messageList.addMessage('Operator', data);
          });

          stream2.on('message', function (data) {
          });

          stream2.on('error', function (err) {
          });

        }).catch(function (error) {
          console.log(error);
        });
    }

  }

  function takeNextCall() {
      $.ajax('/connect/' + '<%- user.clientName %>')
        .done(function (text) {
          console.log(text);
          if(text === 'Empty Queue') {
            alert('Queue is currently empty');
          }
        })
        .fail(function () {
          alert('Could not connect!');
        });
    }
</script>